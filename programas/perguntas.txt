João José Neto
14:59
Alguém me ouve?

Bruno Henrique Koga Fazano
14:59
não consigo ouvir prof

João José Neto
14:59
então vai ser chat mesmo

Arthur da Rosa Almeida
14:59
também não consigo ouvir

Bruno Henrique Koga Fazano
15:00
voce esta usando o safari?

João José Neto
15:00
entrei neste:    https://meet.google.com/utj-wgrv-oym?authuser=1

Andre Victor Fernandes Bacci
15:01
ficamos por chat então

João José Neto
15:01
É bom ver a classe cheia.
vamos lá então.
quem começa?

Andre Victor Fernandes Bacci
15:02
escutou minha dúvida, prof?

João José Neto
15:02
parece que o André falou alguma coisa

Andre Victor Fernandes Bacci
15:03
perguntei se o loader pode ser feito em alto nível

João José Neto
15:03
não ouvi nada]

Andre Victor Fernandes Bacci
15:03
estou fazendo em python e fiz uma classe bem simples para o loader que pega o programa .hex montado em linguagem de máquina e aloca para a memória da MVN

João José Neto
15:04
O loader absoluto, aquele de carregar programas na memória do processador, precisa ser feito em linguagem de máquina.
isso já ajuda a testar o simulador do processador

Andre Victor Fernandes Bacci
15:05
nesse caso o programa do loader será alocado para a memória do processador?
fico um pouco confuso com isso

João José Neto
15:06
exatamente como se faz na máquina real: coloca-se o código "na marra" nas suas posições de memória e dá-se partida no simulador a partir da sua primeira instrução.

João José Neto
15:07
estamos no ar ainda?

Andre Victor Fernandes Bacci
15:08
sim

João José Neto
15:08
ok

Felipe Kenzo Kusakawa Mashuda
15:08
Professor, estou confuso pois não sei como ler o arquivo de dentro da maquina virtual; seria o caso de implementar por meio de chamada de sistema?

João José Neto
15:10
existe na MVN uma instrução de entrada de dados e outra de saída. Usem esta instrução para pegar o próximo byte do arquivo, ou para colocar no arquivo mais um byte.

Andre Victor Fernandes Bacci
15:10
nesse caso então implementamos get data e put data como instruções de leitura e escrita de arquivo
é isso?

João José Neto
15:12
isso, sempre lembrando que é como se fosse a simulação de uma E/S em fita de papel

Lucas Yuji Harada
15:12
o acumulador da MVN tem que ser de quantos bits? pq tem instrucao como o load_value que tem argumentos de 12 bits, mas existem instrucoes como move_to_memory que falam pra guardar o acumulador de memoria em apenas um endereco (ou seja, 8bits), entao esta meio conflitante isso

João José Neto
15:12
próximo?
acumulador e memória 8 bits

Andre Victor Fernandes Bacci
15:13
lucas, vc pode mutar seu microfone?

João José Neto
15:14
endereços são de 12 bits (para poder endereçar 4k bytes

Bruno Henrique Koga Fazano
15:14
professor, não entendi bem a parte do loader, como fazer em linguagem de máquina?

Felipe Kenzo Kusakawa Mashuda
15:14
Professor, eu já implementei com acumulador de 16 bits. Posso deixar assim e só explicar no relatório?

João José Neto
15:14
load value só usa os 8 bits menos significativos daqueles doze.

Andre Victor Fernandes Bacci
15:16
devemos implementar as pseudoinstruções DB, DW e DA? O que eu implementei foi uma única pseudoinstrução K que utiliza como operando um dado de 1byte.

João José Neto
15:16
se você implementou acumulador de 16bits, como funciona LOAD e MM ? A memória só tem 8 bits.

Felipe Kenzo Kusakawa Mashuda
15:16
leio duas posições por vez

Leonardo Akira Shimabukuro
15:18
Professor, o dumper é implementado em linguagem de máquina? Se sim, ele deve copiar a memória para a saída em um formato que possa ser carregado pelo loader?

João José Neto
15:18
|DB, DW, DA são pseudo instruções do montador., para definir byte, word e endereço respectivametne.. pode ser compactado em um só, mas precisa de algum mecanismo para distinguir os tipos de dados dos operandos.

Andre Victor Fernandes Bacci
15:18
certo, entendi

João José Neto
15:18
Felipe, depois me mande um e-mail com detalhes dessa sua dúvida.

Andre Victor Fernandes Bacci
15:19
por enquanto não é necessário elaborar um relatório, certo? apenas postar os arquivos do programa e um README com instruções de uso?

João José Neto
15:19
leonardo, o dumper não precisa  ser em linguagem de máquina

Pedro Gabriel Mascarenhas Maronezi
15:19
Professor, nós temos que tratar endereçamento indireto no montador?

João José Neto
15:21
andré - o relatório valida os resultados e dá a explicação do que foi feito e de como foi feito. Por enquanto concentre-se em fazer tudo funcionar bem para usar na prova.

Lucas Yuji Harada
15:22
professor, queria entender melhor o funcionamento do loader. Se eu tenho um arquivo .hex no meu computador, como eu devo passar a referencia desse arquivo para o loader da VM?
seria um argumento que o usuario do programa deve fornecer?

João José Neto
15:23
Lucas- a máquina só tem uma entrada e uma saída, então basta antes de começar a simular as coisas informar o programa o nome dos arquivos que constituem a entrada e a saída deste programa.
Mais perguntas?

Andre Victor Fernandes Bacci
15:25
é necessário pensar no caso de programas em .asm que possuam duas instruções do tipo @?
pois o montador deveria gerar duas "fitas" e portanto dois arquivos .hex, certo?

João José Neto
15:26
Cada programa pode ter tantas instruções de cada tipo quantas precisar. o montador deve estar preparado para isso. Só uma correção: @ não é instrução, é pseudo.
Não, cada @ inicia um bloco da fita que está sendo criada, e não encerra a fita.

Andre Victor Fernandes Bacci
15:27
como distinguimos entre os blocos das fitas?
em hexadecimal

João José Neto
15:28
cada bloco começa com o número de bytes, o endereço inicial , os bytes de dados e um checksum. 

Felipe Kenzo Kusakawa Mashuda
15:29
Professor, vc pode elaborar as instruções de chamada de subrotina e de retorno de subrotina? Acabei implementando com stack pointer pq não entendi direito

João José Neto
15:29
que você quis dizer com "em hexadecimal"?

Andre Victor Fernandes Bacci
15:30
mas no arquivo .hex, como saberemos se estamos falando de um novo bloco? como o loader saberá que aquele byte não é pra ser alocado na memória, mas é um byte de controle?

João José Neto
15:30
felipe, é uma longa história, que eu já respondi para alguém. Mande-me um e-mail e vou ver se consigo resgatar a resposta

Felipe Kenzo Kusakawa Mashuda
15:31
okay

Andre Victor Fernandes Bacci
15:31
seria pela quantidade de bytes que ele leu no começo do bloco? daí, quando ele já ultrapassou essa quantidade, o próximo byte é um novo bloco?

João José Neto
15:35
andré- exatamente. tem que ir contando os dados extraídos e usando os metadados para controlar o início e o final dos blocos. Além disso, o checksum ajuda a evitar erros de leitura.

Leonardo Akira Shimabukuro
15:36
Considerando que podem haver vários blocos em uma fita, como o loader determina quantos blocos precisam ser lidos, ou seja, como ele determina que não há mais dados a serem lidos da fita de entrada? O montador precisa incluir o número de blocos no início do código-objeto?

João José Neto
15:37
leo- ele vai lendo até o fim do arquivo, que funciona como aqueles 40 zeros binários da fita.
assim náo há necessidade de ter o número de blocos

João José Neto
15:38
deixei alguma pergunta sem resposta (exceto as duas que vou responder fora do chat?)

Lucas Yuji Harada
15:39
sobre a instrucao de chamada ao sistema operacional, que tipo de coisas  o sistema operacional deve realizar?

João José Neto
15:40
por ora, nenhuma, mas em breve vocês poderão ter algumas funções de sistema que sejam convenientes (por exemplo, entre outros, para controlar o uso de arquivos com programas em linguagem de máquina prontos para serem carregados)

Leonardo Akira Shimabukuro
15:42
Quanto à detecção do final do arquivo de entrada, isso pode ser passado ao loader pela máquina hospedeira através de uma chamada de instrução de sistema operacional?

João José Neto
15:44
Quando você manda entrar o próximo dado, se vier END OF FILE, isso indica o final da fita (e do arquivo de entrada que a simula) portanto não há necessidade de simular o sistema operacional para isso.

Você
15:44
Professor, como deve ser o formato do arquivo de entrada? Pode ser um .txt em hexadecimal?

João José Neto
15:45
bernardo, sim.
o importante é interpretar corretamente  o seu conteúdo.

Felipe Kenzo Kusakawa Mashuda
15:46
Professor, posso encapsular a máquina em uma interface que aponte qual deve ser o arquivo de entrada e o de saída?

João José Neto
15:47
foi o que eu sugeri agora há pouco: como a máquina só tem uma entrada e uma só saída, dá para fazer isto .

Felipe Kenzo Kusakawa Mashuda
15:47
Que permita também outras interações, por exemplo, ligar/desligar a máquina, modificar os registradores, adicionar breakpoints, encapsule o assembler também
opa
okay
obrigado

Andre Victor Fernandes Bacci
15:47
professor, o loader não pode ter endereçamento indireto?

João José Neto
15:48
Um disco será utiilizado para guardar os arquivos mais para a frente.

João José Neto
15:50
andré - não há indireto nesta máquina. não é possível alterar o conjunto de instruções, então você vai precisar sintetizar um endereçamento indireto. Pense um pouco nisso e se tiver muita dificuldade, escreva-me sobre a dúvida.

Leonardo Akira Shimabukuro
15:50
Professor, ainda não entendi essa detecção do END OF FILE. A instrução Get Data precisa tratar isso de forma diferente (realizar um salto ou armazenar um valor específico no acumulador)?

João José Neto
15:51
UM MOMENTO _ VOU ME AFASTAR UM POUCO DO COMPUTADOR MAS VOLTO JÁ 15:51

João José Neto
15:55
PRONTO - ESTOU DE VOLTA.

Andre Victor Fernandes Bacci
15:56
estou com bastante dificuldade de visualizar como faremos esse loader absoluto com um acumulador de 8 bits

João José Neto
15:59
Leo - Você deve usar para a leitura do arquivo alguma função de sistema hospedeiro que lhe forneça os dados ou uma indicação que o arquivo terminou. A Get Data ao tentar ler além do arquivo deve retornar com uma indicação de END OF FILE. Como você está usando texto hexa, então pode empregar qualquer código que não seja válido para indicar fim de arquivo, se assim achar melhor.

Andre Victor Fernandes Bacci
16:00
porque fica impossível armazenar o contador de instruções de 12 bits no acumulador, e temos que operar em cima dos bytes1 e 2 do endereço para poder juntá-los em um operando só.

João José Neto
16:02
André - Nos slides tem até um diagrama de blocos pronto da lógica deste loader. Você deve adaptá-lo para executar na MVN. Dê uma olhada nisso e me mande as dúvidas por e-mail.

Andre Victor Fernandes Bacci
16:02
ok

Bruno Henrique Koga Fazano
16:03
Professor, temos outra aula agora as 16h
Vou deixar a chamada aberta caso alguem mais queira perguntar algo, mas vou sair. Obrigado pela disponibilidade e boa tarde!

João José Neto
16:05
OK. Foi um prazer estar virtualmente com vocês. Espero que essa pandemia acabe logo para podermos estar juntos novamente. Tchau. Se precisarem de mais sessoes como esta me avisem.

